* Org Zettelkasten
#+CAPTION: User Interface
[[file:images/interface.png]]

** Selecting Files
#+begin_src emacs-lisp
(defun org-zk-files-with-titles ()
  "Returns an alist of entries (title . filename)"
  (org-el-cache-mapcan-files
   (lambda (file cache-entry)
     (let ((category (plist-get cache-entry :category))
           (title (or (org-el-cache-get-keyword file "TITLE") file)))
       (if category
           (list
            (cons
             (format "%s (%s)" title (org-zk-category-name category))
             file)))))))

(defvar org-zk-ivy-histoy nil)

(defun org-zk-select-file (action)
  (ivy-read
   "File: "
   (org-zk-files-with-titles)
   :history 'org-zk-ivy-history
   :action action))
#+end_src

#+RESULTS:
: org-zk-select-file
** Opening Files
#+begin_src emacs-lisp
(defun org-zk-open-file ()
  "Select a file, then open it"
  (interactive)
  (org-zk-select-file (lambda (selection) (find-file (cdr selection)))))
#+end_src
** Linking Files
#+begin_src emacs-lisp
  (defun org-zk-link-file ()
    "Select a file, then insert an org-mode link to it"
    (interactive)
    (org-zk-select-file
     (lambda (selection)
       (insert (org-zk-make-link
                (cdr selection)
                (org-zk-file-title (cdr selection)))))))

  (defun org-zk-copy-link-to-file ()
    "Create an org link to the current file and copy it to the kill-ring"
    (interactive)
    (kill-new (org-zk-make-link (buffer-file-name))))
#+end_src
** Creating Files
#+begin_src emacs-lisp
(defun org-zk-new-file (&optional insert-link)
  "Create a new org zettelkasten file.
Prompts for a title, and a project, then uses the projects
name-fn to generate a filename."
  (interactive)
  (org-zk-category-prompt
   (lambda (category)
     (let* ((category (cdr category))
            (title (org-zk-read-title))
            (link-fn (org-zk-category-link-fn category))
            (name-fn (org-zk-category-name-fn category))
            (setup-fn (org-zk-category-setup-fn category))
            (name (funcall name-fn title))
            (file (expand-file-name
                   (concat name ".org")
                   (org-zk-category-path category))))
       (if (file-exists-p file)
           (error "Aborting, file already exists: %s" file))
       (when insert-link
         (insert (funcall link-fn file title))
         (save-buffer))
       (find-file file)
       (funcall setup-fn title)
       (save-buffer)))))

(defun org-zk-create-file (title category)
  "Create a new org zettelkasten file given its category and title.
Returns the name of the new file"
  (let* ((link-fn (org-zk-category-link-fn category))
         (name-fn (org-zk-category-name-fn category))
         (setup-fn (org-zk-category-setup-fn category))
         (name (funcall name-fn title))
         (file (expand-file-name
                (concat name ".org")
                (org-zk-category-path category))))
    (if (file-exists-p file)
        (error "Aborting, file already exists: %s" file))
    (with-current-buffer (find-file-noselect file)
      (funcall setup-fn title)
      (save-buffer)
      (kill-buffer))
    file))

(defun org-zk-new-file-and-link ()
  "Create a new org zettelkasten file and insert a link to it at
point."
  (interactive)
  (org-zk-new-file t))
#+end_src
** ID on every heading                                            :inactive:
#+begin_src
(defun org-zk-add-ids-to-headlines ()
  "Make sure all headlines in the current file have an ID property"
  (interactive)
  ;; Can't use `org-map-entries' as it opens a prompt when run inside
  ;; a buffer that hasn't been saved yet (Non-existing file / org
  ;; agenda)
  (save-excursion
    (goto-char (point-max))
    (while (outline-previous-heading)
      (org-id-get-create))))

(add-hook 'org-mode-hook
          (lambda ()
            (add-hook 'before-save-hook 'org-zk-add-ids-to-headlines nil 'local)))
#+end_src
** Inspiration
*** David Allen - Getting Things Done                                :book:
*** Lion Kimbro - [[https://users.speakeasy.net/~lion/nb/html/][How to Make a Complete Map of Every Thought You Think]] :website:
*** Niklas Luhman - Zettelkasten
** Stability
This package should be considered *work in progress* / *unstable*.  I
use it on a daily basis but the API might change in breaking ways.
** Dependencies
- [[https://github.com/abo-abo/swiper][abo-abo/swiper]]
  For searching / selecting files
- [[https://github.com/abo-abo/ace-link][abo-abo/ace-link]]
  For following links
- [[https://github.com/abo-abo/hydra][abo-abo/hydra]]
** Full-Text Search
While a simple =grep= or =awk= would be sufficient for most searches, this
package contains a small C++ wrapper for the [[https://xapian.org/][Xapain]] search engine
library.

This makes it possible to search for files using queries with boolean
operators and matching of synonyms.

See [[https://xapian.org/docs/queryparser.html][Xapian Docs - Query Parser]] for details on this.
*** NEXT Switch to Rust search engine
*** TODO Document dependencies needed
*** TODO Document installation
*** TODO Document executable paths
** Components
*** ~org-zk-keywords~
File-level attributes are stored as =#+KEY: value= org mode keywords.
These should be placed at the start of the file, not containing any
newlines before or between keywords.

- ~(org-zk-keywords-set-or-add (key value))~
- ~(org-zk-keywords-add (key value))~
- ~(org-zk-keywords-delete (key))~

The macro ~org-zk-def-keyword~ can be used to create commands to set
keywords to one of a list of predefined values using ~ivy-read~.
When generating the functions name, the keyword is converted to
lowercase and "_" are replaced by "-".

**** Example
#+begin_src emacs-lisp
  (org-zk-def-keyword
   "GTD_STATE"
   '("active"
     "someday"
     "planning"
     "cancelled"
     "done"))
#+end_src

Generated function: ~org-zk-set-gtd-state~
*** ~org-zk-cache~
By default, emacs is not fast enough to efficiently search large collections (>1k
files) for TODO keywords, tags, dates etc.

To get around this limitation, a cache is introduced.

This cache works by running ~org-element-process-buffer~ each time a
file is saved or the buffer moves out of focus (e.g. when switching to
another window or buffer).

Sub-modules can register on element types to compute data on a file or
headline level that can then be used to implement fast views on all
the data in the zettelkasten, e.g. for listing open projects, tasks or
calendar entries, generating clocking reports and statistics or for
use with the integrated spaced repetition system.

A query language is implemented on this cache for building custom
views on the data.
*** ~org-zk-links~
There are three types of links, *parent*, *child* and *friend*.

When adding a link to some target, a link pointing back to the
current file is added to the link list of the target file,
using the inverse (parent <-> child, friend <-> friend) link type.

Links to other files that are not part of the main text are placed in
a list at the beginning of the file, right after the keywords.

When adding links, the current search term can be used to create a
new note using ~ivy-immediate-done~, by default bound to ~C-M-j~.

I've rebound it to ~C-d~.

#+begin_src emacs-lisp
  (define-key ivy-minibuffer-map (kbd "C-d") 'ivy-immediate-done)
#+end_src

The ~org-zk-hydra~ can be used to quickly add links to the current file.
If *follow-mode* is active, after adding a link the target file is
opened. This is useful for quickly creating "mind-maps" without
entering text or other links to each file.
*** ~org-zk-titlecase~
When creating a note using the ~org-zk~ commands,
the title that is entered is automatically converted to title-case.

This only works for English text and not all rules are implemented.
Multi-word conjunctions are not supported yet.
** Testing
Integration testing is done by providing an input file,
a set of operations and an file with the expected output.

The output is written to a third =_got= file, which can be diffed with
the expected output or used to replace the =_expected= file if the
output generated was valid.
** ~awk~
~awk~ is used to extract timestamps, TODO headlines and flashcard
spacing information from the collection of files.

This has two important implications:

Each headline needs an ~:ID:~ property,
this is enforced via a ~before-save~ hook.

IDs should be generated so that a heading can be identified *uniquely*
identified given the filename and an ID.

Files should be saved as often as possible,
this is saving buffers when they are switched away from.
** ~git~
I'm willing to sacrifice a bit of memory and meaningful commit
messages to make sure no information / history is lost.

Files are committed to version control every hour.
** Ivy
[[https://github.com/abo-abo/swiper]]

** Hydra
Used to implement a self-documenting modal editing layer.
** Design Goals
*** Optimize for performance
*** Full-text search
*** Prefer specific custom code to extending / configuring existing code
*** Prefer small files to large ones split into sections
*** Designed for use with the GTD method
*** Modular building blocks for flexible systems
*** Reuse of existing packages
- org-ql
- org-superagenda
** Long Term Goals
*** Back by graph database
E.g. [[https://github.com/indradb/indradb][indradb]]
*** Integrate with [[https://github.com/remacs/remacs][remacs]]
For direct bindings from rust to emacs-lisp
*** Replace Xapian with something written in rust
[[https://github.com/toshi-search/Toshi]]
** Performance
Searching a collection of 915 files (160k words) for =NEXT= tasks in
active projects takes around 5ms.

Running a full-text search against the same collection of files takes
30ms.

Benchmark were run on a Thinkpad L470 (SSD, i5-2700U 2.5GHz).
** Cache
There are a few other packages that provide more advanced / performant
queries on org-mode files:

- [[https://github.com/alphapapa/org-ql][org-ql]]
- [[https://github.com/ndwarshuis/org-sql][org-sql]]

This package implements a cache for files and headlines using a hash
table directly in Emacs, no external database is needed.

To avoid recreating this table on each startup, it can be written to
disk at regular intervals and when Emacs is closed.

Each file entry has a hash value that is checked against the files
hash on startup. With this, updating the cache for my collection of
files takes around 5s.

Cache entries are updated when a =.org= file is saved, created, moved
or deleted.
** TODO Graph View
- [X] generate graph image from file links
- [ ] update graph view split on file change
- [ ] use colors from Emacs colorscheme
** TODO Derived Tasks
Some tasks can be fully derived from the current state of the rest of
the system.

Examples:
- Reviewing due flashcards
- Processing the Inbox
- Reading mail

This could be implemented by skipping the detour through .org files on
disk and adding derived tasks to the list when opening the task view.

The downside of this approach is that these tasks would not show up in
the default org-agenda an keeping track of their time-tracking
information would require an additional database.

Instead, derived tasks are implemented by checking for some condition
in regular intervals, then adding a headline to a predefined file.

To avoid cluttering this file, if it already includes a headline with
the same title that is not marked as "DONE", no new entry is added.

Derived tasks are stored in a hash-table to simplify changing the
predicate of an existing derived task.

Therefore, each derived task should have *a unique task title*.

Derived tasks can be registered using the ~(def-org-zk-derived-task
title priority tags predicate)~ macro.

The example below adds a new task "Process Inbox" if there are at
least five entries in the inbox.

#+begin_src emacs-lisp
  (def-org-zk-derived-task "Process Inbox" "A" '("gtd")
    (>= (org-zk-inbox-count) 5))
#+end_src
** Project View
Files can be tagged as GTD projects using the =#+GTD_STATE= keyword.

Based on this keyword, a view of all (active) projects can be created
and it's easy to mark a whole project as =on_hold= or =someday= to
remove it's tasks from the task view.

*** TODO Project Priorities
Similar to tasks, files can be assigned different priorities and
states in order to represent GTD projects.

I find the priorities built into org-mode very limiting.
While it's possible to define more priorities than the default =#A=,
=#B=, =#C=, there is no easy way to assign priorities to projects
that is then factored in when sorting =NEXT= tasks by priority.

- Nested
- Multiplicative or additive
** Task View
This package implements its own simple version of the =org-agenda=
task list. based on =tabulated-list-mode=.

I mainly use this to get a view of all =NEXT= tasks, sorted by
priority, to see what I should work on next.
** Calendar View
Derived from the task view, filtered by tasks due in some span of time.
*** TODO Allow custom views based on filter rules
*** TODO Fix handling of links in headings
*** WAITING Wrapper around org agenda
CLOSED: [2019-12-12 Thu 10:23]
:LOGBOOK:
- State "WAITING"    from "NEXT"       [2019-12-12 Thu 10:23]
:END:
Set source files on function call,
use projects containing timestamps for this
** Edges and Links Between Files
There are two ways of linking files together,
using the *edges* list at the beginning of the file
or using *inline-links* in the main text.

Both use the default org-mode link syntax.

*Edges* should only be manipulated using the functions in
~org-zk-links~ to ensure the edge list of the target file is updated
to.

- ~org-zk-remove-edge~ :: Select & remove an edge from both files
- ~org-zk-add-edge~ :: Add an edge to both files
- ~org-zk-add-yank-link~ :: If the kill-ring / clipboard contains a
  valid URL, insert it in the file's link list.

*** TODO Add block
Edges are wrapped in a =ZK_EDGES= block so that the list can be
collapsed when using the graph viewer.

No such restriction applies to *inline-links*.

*** TODO Outline Sidebar, Visualization
*** TODO Graph Queries / Graph Database
I'd like to ask the system questions like “Which concepts are
introduced in books by $author”.

This might be implemented by syncing file properties and edges to a
graph database like neo4j or by implementing a Prolog-like language in
emacs-lisp.
